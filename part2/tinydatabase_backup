/*
 Package tinydatabase provides simple database functions.
*/
package tinydatabase

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"errors"
	//"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"path"
	//"strconv"
	"time"
)

type ColumnType struct {
	Name string
	Type string
	Size int64 //When Size is 0, size of the column can be variable
}

type Row map[string]interface{}

type TableInterface interface {
	NewTable(directory string, tablename string, columnTypes []ColumnType) error
	Open(directory string, tablename string) error
	Close() error
	ReadRow(rowNum int64) (Row, error)
	WriteRow(rowNum int64, row Row) (int64, error)
	DeleteRow(rowNum int64) error
}

type TableStatic struct {
	tablefile   *os.File
	fileVersion int64
	columnTypes []ColumnType
	columnBytes int64
}

type TableDynamic struct {
	tablefile           *os.File
	indexfile           *os.File
	fileVersion         int64
	columnTypes         []ColumnType
	columnBytes         int64
	numOfFlexibleColumn int64
}

const (
	UNKNOWN  int64 = 0
	STATIC1  int64 = 1
	DYNAMIC1 int64 = 2
)

const (
	ROW_DELETED byte = 0
	ROW_NORMAL  byte = 1
)

/*type TinyDatabaseError struct {
	Id      int
	Message string
}*/

/*
 NewTable func creates table file and config file.
 When files exist, returns error.
*/
func (self *TableStatic) NewTable(directory string, tablename string, columnTypes []ColumnType) error {
	directory = path.Clean(directory)
	directory = directory + "/"
	dCheck, err := os.Stat(directory)
	dCheck = dCheck
	/*if err != nil {
		return err
	}
	if dCheck.IsDir() == false {
		return errors.New("Directory does not exist.")
	}

	_, err = os.Stat(directory + tablename + ".config")
	if err == nil {
		return errors.New("Config file exists.")
	}
	_, err = os.Stat(directory + tablename + ".table")
	if err == nil {
		return errors.New("Table file exists.")
	}*/

	err = self.setColumns(columnTypes)
	if err != nil {
		return err
	}
	err = self.saveConfigFile(directory + tablename + ".config")
	if err != nil {
		return err
	}

	err = self.openTableFile(directory + tablename + ".table")
	if err != nil {
		return err
	}
	return nil
}

func (self *TableStatic) Open(directory string, tablename string) error {
	err := self.Close()
	if err != nil {
		return err
	}
	directory = path.Clean(directory)
	directory = directory + "/"
	err = self.openConfigFile(directory + tablename + ".config")
	if err != nil {
		return err
	}
	err = self.openTableFile(directory + tablename + ".table")
	if err != nil {
		return err
	}
	return nil
}

func (self *TableStatic) Close() error {
	if self.tablefile == nil {
		return nil
	}
	err := self.tablefile.Close()
	if err != nil {
		return err
	}
	self.tablefile = nil
	return nil
}

func (self *TableStatic) WriteRow(rowNum int64, row Row) (int64, error) {
	if rowNum == -1 {
		temp, err := self.searchLastOff()
		if err != nil {
			return -1, err
		}
		rowNum = temp
	}
	targetOff := self.convertRowNumToOffset(rowNum)
	var b []byte
	b = make([]byte, 1)
	b[0] = ROW_NORMAL
	num, err := self.tablefile.WriteAt(b, targetOff)
	if err != nil {
		return -1, err
	}
	targetOff = targetOff + int64(num)
	for _, v := range self.columnTypes {
		if val, ok := row[v.Name]; ok {
			b, err = v.ConvertToBytes(val)
			if err != nil {
				return -1, err
			}
		} else {
			b, err = v.GetNil()
			if err != nil {
				return -1, err
			}
		}
		num, err := self.tablefile.WriteAt(b, targetOff)
		if err != nil {
			return -1, err
		}
		targetOff = targetOff + int64(num)
	}
	err = self.tablefile.Sync()
	if err != nil {
		return -1, err
	}
	return rowNum, nil
}

func (self *TableStatic) ReadRow(rowNum int64) (Row, error) {
	targetOff := self.convertRowNumToOffset(rowNum)

	var b []byte
	b = make([]byte, 1)
	_, err := self.tablefile.ReadAt(b, targetOff)
	if err != nil {
		return nil, err
	}
	if b[0] == ROW_DELETED {
		return nil, errors.New("Deleted row")
	}
	targetOff = targetOff + 1

	result := make(Row)
	for _, v := range self.columnTypes {
		b, err = v.GetNil()
		if err != nil {
			return nil, err
		}
		_, err = self.tablefile.ReadAt(b, targetOff)
		if err != nil {
			return nil, err
		}
		result[v.Name], err = v.ConvertToVal(b)
		if err != nil {
			return nil, err
		}
		nextOff, err := v.GetBytes()
		if err != nil {
			return nil, err
		}
		targetOff = targetOff + int64(nextOff)
	}
	return result, nil
}

func (self *TableStatic) DeleteRow(rowNum int64) error {
	targetOff := self.convertRowNumToOffset(rowNum)
	var b []byte
	b = make([]byte, 1)
	b[0] = ROW_DELETED
	_, err := self.tablefile.WriteAt(b, targetOff)
	err = self.tablefile.Sync()
	if err != nil {
		return err
	}
	return nil
}

//**************************************************

func (self *ColumnType) GetBytes() (int64, error) {
	if self.Type == "int64" {
		return binary.MaxVarintLen64, nil
	} else if self.Type == "float64" {
		return 8, nil
	} else if self.Type == "string" {
		return self.Size, nil
	} else if self.Type == "time" {
		return 15, nil
	}
	return 0, errors.New("Type is not valid")
}

func (self *ColumnType) GetNil() ([]byte, error) {
	var b []byte
	byteNum, err := self.GetBytes()
	if err != nil {
		return nil, err
	}
	b = make([]byte, byteNum)
	if self.Type == "int64" {
		binary.PutVarint(b, int64(0))
		return b, nil
	} else if self.Type == "float64" {
		bits := math.Float64bits(0.0)
		binary.LittleEndian.PutUint64(b, bits)
		return b, nil
	} else if self.Type == "string" {
		return b, nil
	} else if self.Type == "time" {
		b, err = time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC).MarshalBinary()
		if err != nil {
			return nil, err
		}
		return b, nil
	} else {
		return nil, errors.New("Type is not valid")
	}
}

func (self *ColumnType) ConvertToBytes(val interface{}) ([]byte, error) {
	var b []byte
	byteNum, err := self.GetBytes()
	if err != nil {
		return nil, err
	}
	if self.Type == "int64" {
		var v int64
		switch vi := val.(type) {
		case int64:
			v = vi //.(int64)
		case int:
			v = int64(vi)
		case int8:
			v = int64(vi)
		case int16:
			v = int64(vi)
		case int32:
			v = int64(vi)
		default:
			return nil, errors.New("Missmatch type(int64) and val: " + self.Name)
		}
		b = make([]byte, byteNum)
		binary.PutVarint(b, v)
		return b, nil
	} else if self.Type == "float64" {
		v, ok := val.(float64)
		if ok == false {
			return nil, errors.New("Missmatch type(float64) and val: " + self.Name)
		}
		b = make([]byte, byteNum)
		bits := math.Float64bits(v)
		binary.LittleEndian.PutUint64(b, bits)
		return b, nil
	} else if self.Type == "string" {
		v, ok := val.(string)
		if ok == false {
			return nil, errors.New("Missmatch type(string) and val: " + self.Name)
		}
		b = make([]byte, byteNum)
		for i := 0; i < len(v); i++ {
			b[i] = v[i]
		}
		return b, nil
	} else if self.Type == "time" {
		v, ok := val.(time.Time)
		if ok == false {
			return nil, errors.New("Missmatch type(time) and val: " + self.Name)
		}
		b, err = v.MarshalBinary()
		if err != nil {
			return nil, err
		}
		return b, nil
	} else {
		return nil, errors.New("Type is not valid: " + self.Name)
	}
}

func (self *ColumnType) ConvertToVal(b []byte) (interface{}, error) {
	if self.Type == "int64" {
		var v int64
		v, num := binary.Varint(b)
		if num < 1 {
			return nil, errors.New("Missmatch type(int64) and val: " + self.Name)
		}
		return v, nil
	} else if self.Type == "float64" {
		bits := binary.LittleEndian.Uint64(b)
		v := math.Float64frombits(bits)
		return v, nil
	} else if self.Type == "string" {
		n := bytes.IndexByte(b, 0)
		v := string(b[:n])
		return v, nil
	} else if self.Type == "time" {
		var v time.Time
		err := v.UnmarshalBinary(b)
		if err != nil {
			return nil, err
		}
		return v, nil
	} else {
		return nil, errors.New("Type is not valid: " + self.Name)
	}
}

//**************************************************

func (self *TableStatic) openConfigFile(configfilename string) error {

	jsonString, err := ioutil.ReadFile(configfilename)
	if err != nil {
		return err
	}

	var columnTypes []ColumnType
	err = json.Unmarshal(jsonString, &columnTypes)
	if err != nil {
		return err
	}
	err = self.setColumns(columnTypes)
	if err != nil {
		return err
	}

	return nil
}
func (self *TableStatic) openTableFile(tablefilename string) error {
	f, err := os.OpenFile(tablefilename, os.O_RDWR+os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	self.tablefile = f

	b := make([]byte, binary.MaxVarintLen64)
	num, err := self.tablefile.ReadAt(b, 0)
	if err != nil {
		if err == io.EOF {
			self.fileVersion = STATIC1
			binary.PutVarint(b, self.fileVersion)
			num, err = self.tablefile.WriteAt(b, 0)
			if err != nil {
				return err
			}
		} else {
			return err
		}
	} else {
		self.fileVersion, num = binary.Varint(b)
		if num == 0 {
			return errors.New("Failed to read fileversion")
		}
		if self.fileVersion != STATIC1 {
			return errors.New("Fileversion is not correct")
		}
	}

	return err
}

func (self *TableStatic) saveConfigFile(configfile string) error {
	b, err := json.Marshal(self.columnTypes)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(configfile, b, os.ModePerm)
	if err != nil {
		return err
	}
	return nil
}

func (self *TableStatic) setColumns(columnTypes []ColumnType) error {
	columnBytes := int64(0)
	flags := map[string]int{}

	for _, val := range columnTypes {
		_, ok := flags[val.Name]
		if ok == true {
			return errors.New("Same column name exists.")
		}
		flags[val.Name] = 1
		num, err := val.GetBytes()
		if err != nil {
			return err
		}
		val.Size = num
		columnBytes = columnBytes + num
	}
	self.columnTypes = columnTypes
	self.columnBytes = columnBytes
	return nil
}

func (self *TableStatic) convertRowNumToOffset(rowNum int64) int64 {
	offset := int64(rowNum)*int64(self.columnBytes+1) + int64(binary.MaxVarintLen64)
	return offset
}
func (self *TableStatic) convertOffsetToRowNum(offset int64) int64 {
	rowNum := int64((offset - int64(binary.MaxVarintLen64)) / (int64(self.columnBytes + 1)))
	return rowNum
}

func (self *TableStatic) searchLastOff() (int64, error) {
	lastOff, err := self.tablefile.Seek(0, 2)
	if err != nil {
		return -1, err
	}
	rowNum := self.convertOffsetToRowNum(lastOff)
	return rowNum, err
}

/*func fileExists(name string) bool {
	_, err := os.Stat(name)
	return err == nil
}

func (self TinyDatabaseError) Error() string {
	return self.Message
}*/
